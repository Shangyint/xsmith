#lang racket/base

(provide cish2-grammar)

(require
 "../grammar-macros.rkt"
 "../core-properties.rkt"
 "cish2-utils.rkt"
 "../scope-graph.rkt"
 (only-in pprint [empty empty-doc])
 racr
 racket/random
 racket/class
 racket/dict
 )


(define-spec-component cish2-grammar)

(add-to-grammar
 cish2-grammar
 [Node #f ([precomment = empty-doc]
           [postcomment = empty-doc])]
 [Program Node ([declarations : Declaration * = (random 7)]
                [main : FunctionDefinition])]

 [Declaration Node ([liftdepth = 0]
                    [type = #f]
                    [name = (fresh-var-name "x_")])]
 [VariableDeclaration Declaration (Expression)]
 [FunctionDefinition Declaration ([params : FormalParam *]
                                  Block)]
 [FormalParam Node ([type = (fresh-var-type)]
                    [name = (fresh-var-name "arg_")])]


 [Statement Node ()]
 [NullStatement Statement ()]
 [Block Statement ([declarations : Declaration * = (random 2)]
                   [statements : Statement * = (add1 (random 4))])]
 [ExpressionStatement Statement (Expression)]
 [IfStatement Statement ([test : Expression]
                         [then : Statement])]
 [IfElseStatement IfStatement ([else : Statement])]
 [ReturnStatement Statement ()]
 ;[VoidReturnStatement ReturnStatement ()]
 [ValueReturnStatement ReturnStatement (Expression)]

 [LoopStatement Statement ([test : Expression]
                           [body : Statement])]
 [WhileStatement LoopStatement ()]
 [DoWhileStatement LoopStatement ()]
 [ForStatement LoopStatement ([init : Declaration]
                              [update : Expression])]

 [Expression Node ()]

 [AssignmentExpression Expression ([name = "standin-name"]
                                   Expression)]
 [FunctionApplicationExpression Expression ([function : VariableReference]
                                            [args : Expression *])]
 [BinaryExpression Expression ([l : Expression]
                               [r : Expression])]
 [AdditionExpression BinaryExpression ()]
 [UnsafeAdditionExpression AdditionExpression ()]
 [SubtractionExpression BinaryExpression ()]
 [UnsafeSubtractionExpression SubtractionExpression ()]
 [MultiplicationExpression BinaryExpression ()]
 [UnsafeMultiplicationExpression MultiplicationExpression ()]
 [DivisionExpression BinaryExpression ()]
 [UnsafeDivisionExpression DivisionExpression ()]

 [IntOnlyBinaryExpression BinaryExpression ()]
 [ModulusExpression IntOnlyBinaryExpression ()]
 [UnsafeModulusExpression ModulusExpression ()]

 [ComparisonExpression BinaryExpression ()]
 [EqualityExpression ComparisonExpression ()]
 [GreaterThanExpression ComparisonExpression ()]
 [LessThanExpression ComparisonExpression ()]
 [LessOrEqualExpression ComparisonExpression ()]
 [GreaterOrEqualExpression ComparisonExpression ()]

 [IfExpression Expression ([test : Expression]
                           [then : Expression]
                           [else : Expression])]
 [LiteralInt Expression (val)]
 [LiteralFloat Expression (val)]
 [VariableReference Expression (name)]

 )

(add-prop cish2-grammar
          may-be-generated
          ;; abstract nodes
          [Declaration #f]
          [Statement #f]
          [ReturnStatement #f]
          [LoopStatement #f]
          [Expression #f]
          [BinaryExpression #f]
          [IntOnlyBinaryExpression #f]
          [ComparisonExpression #f]

          ;; Unsafe nodes should be generated by analysis transformations,
          ;; not random choice.
          [UnsafeAdditionExpression #f]
          [UnsafeSubtractionExpression #f]
          [UnsafeMultiplicationExpression #f]
          [UnsafeDivisionExpression #f]
          [UnsafeModulusExpression #f]
          )

(add-prop cish2-grammar
          depth-increase
          [Block (λ (n) (if (member (node-type (parent-node n))
                                    '(IfStatement
                                      IfElseStatement
                                      FunctionDefinition
                                      ForStatement
                                      WhileStatement
                                      DoWhileStatement))
                            (att-value 'ast-depth (parent-node n))
                            (add1 (att-value 'ast-depth (parent-node n)))))]
          ;; some nodes should never increase depth
          [ExpressionStatement (λ(n)0)]
          [AssignmentExpression (λ(n)0)]
          [Declaration (λ(n)0)])

(add-prop cish2-grammar
          fresh
          [IfElseStatement (hash
                            'then
                            (make-hole 'Block)
                            'else
                            (make-hole 'Block))]
          [AssignmentExpression
           (hash
            'name
            (binding-name (random-ref (send this xsmith_reference-options!))))]
          [VariableReference
           (let* ([choice* (random-ref (send this xsmith_reference-options!))]
                  [choice (if (procedure? choice*) (choice*) choice*)])
             (hash 'name (binding-name choice)))]
          [FunctionApplicationExpression
           (let* ([choice* (random-ref (send this xsmith_reference-options!))]
                  [choice (if (procedure? choice*) (choice*) choice*)])
             (hash 'name
                   (binding-name choice)
                   'args
                   (- (length (binding-type choice))
                      2)))]
          [VariableDeclaration
           (let* ([hole-name (ast-child 'name current-hole)]
                  [name (if (string? hole-name)
                            hole-name
                            (if (equal? (top-ancestor-node current-hole)
                                        (parent-node current-hole))
                                (fresh-var-name "global_")
                                (fresh-var-name "local_")))]
                  [hole-type (ast-child 'type current-hole)]
                  [type (if (and hole-type
                                 (not (and (ast-node? hole-type)
                                           (ast-bud-node? hole-type))))
                            hole-type
                            (fresh-var-type))])
             (hash 'name name
                   'type type))]
          [FunctionDefinition
           (let* ([p (parent-node current-hole)]
                  [main? (and (eq? (node-type p) 'Program)
                              (eq? (ast-child 'main p) current-hole))]
                  [hole-name (ast-child 'name current-hole)]
                  [name (if (string? hole-name)
                            hole-name
                            (if main?
                                "main"
                                (fresh-var-name "func_")))]
                  [hole-type (ast-child 'type current-hole)]
                  [type (if (and hole-type
                                 (not (and (ast-node? hole-type)
                                           (ast-bud-node? hole-type))))
                            hole-type
                            (fresh-function-type))]
                  [params (map (λ (t) (make-fresh-node 'FormalParam
                                                       (hash 'type t)))
                               (reverse (cdr (reverse (cdr type)))))])
             (hash
              'name name
              'type type
              'params params))]
          )

#;(add-prop cish2-grammar
          introduces-scope
          [Program #t]
          [FunctionDefinition #t]
          [Block #t]
          [ForStatement #t])
(add-prop cish2-grammar
          binder-info
          [Declaration (name type)]
          [VariableDeclaration (name type)]
          [FunctionDefinition (name type)]
          [FormalParam (name type)])
(add-prop cish2-grammar
          reference-info
          [VariableReference name]
          [AssignmentExpression name])
(add-prop cish2-grammar
          lift-predicate
          [FunctionDefinition #f]
          ;[FunctionDefinition (λ (n type) #f)]
          [Block (λ (n type) (not (function-type? type)))])
(add-prop cish2-grammar
          lift-type->ast-binder-type
          [#f (λ (type) (if (function-type? type)
                            'FunctionDefinition
                            'VariableDeclaration))])

(define int (base-type 'int))
(define float (base-type 'float))
(define bool (base-type 'bool))
(define type-thunks-for-concretization
  (list (λ () int)
        (λ () float)
        (λ () bool)))
(define concrete-types (map (λ(x)(x)) type-thunks-for-concretization))
(define (fresh-statement-type)
  (fresh-type-variable (return-type (fresh-type-variable))
                       (no-return-type (fresh-type-variable))))
(define (fresh-base-or-function-type)
  (apply fresh-type-variable
         concrete-types
         (function-type (product-type #f)
                        (fresh-type-variable))))
(define no-child-types (λ (t) (hash)))

(add-prop
 cish2-grammar
 type-info
 [Node [(fresh-base-or-function-type) (no-child-types)]]
 [Program [(fresh-type-variable)
           (λ (t) (hash 'main (function-type (product-type '())
                                             int)
                        'declarations (λ (n) (fresh-base-or-function-type))))]]

 ;[Declaration aoeu]
 [VariableDeclaration [(fresh-type-variable)
                       (λ (t) (hash 'Expression t))]]
 [FunctionDefinition [(function-type (product-type #f) (fresh-type-variable))
                      (λ (t) (hash 'Body (return-type t)))]]
 ;[FormalParam aoeu]

 [Statement (fresh-statement-type) (no-child-types)]
 [NullStatement [(fresh-statement-type) (no-child-types)]]
 [Block [(fresh-statement-type)
         (λ (t) (hash 'declarations (λ (n) (fresh-type-variable))
                      'statements (λ (n)
                                    (if (equal? (sub1 (ast-child-index))
                                                (length
                                                 (ast-children (ast-parent n))))
                                        t
                                        (fresh-statement-type)))))]]
 [ExpressionStatement [(fresh-statement-type)
                       (λ (t) (hash 'Expression (fresh-type-variable)))]]
 [IfStatement [(fresh-statement-type)
               (λ (t) (hash 'test bool
                            'then t))]]
 [IfElseStatement [(fresh-statement-type)
                   (λ (t) (hash 'test bool
                                'then t
                                'else t))]]
 [ValueReturnStatement [(return-type (fresh-type-variable))
                        (λ (t) (hash 'Expression (return-type-type t)))]]


 [LoopStatement [(fresh-statement-type)
                 (λ (t) (hash 'test bool
                              'body t))]]
 [ForStatement [(fresh-statement-type)
                (λ (t)
                  (let ([loop-var-type (fresh-type-variable)])
                    (hash 'test bool
                          'body t
                          'init loop-var-type
                          'update loop-var-type)))]]

 [Expression [(fresh-type-variable) (no-child-types)]]

 [AssignmentExpression [(fresh-type-variable)
                        (λ (t) (hash 'Expression t))]]
 ;; TODO - use a reference for the function...
 [FunctionApplicationExpression [(fresh-type-variable)
                                 (λ (t)
                                   (hash 'function (function-type args-type t)
                                         'args (λ (n) (fresh-type-variable))))]]
 ;[BinaryExpression aoeu]
 [AdditionExpression [(fresh-type-variable int float)
                      (λ (t) (hash 'l t 'r t))]]
 [SubtractionExpression [(fresh-type-variable int float)
                         (λ (t) (hash 'l t 'r t))]]
 [MultiplicationExpression [(fresh-type-variable int float)
                            (λ (t) (hash 'l t 'r t))]]
 [DivisionExpression [(fresh-type-variable int float)
                      (λ (t) (hash 'l t 'r t))]]

 [IntOnlyBinaryExpression [int
                           (λ (t) (hash 'l int 'r int))]]

 [ComparisonExpression [(fresh-type-variable bool)
                        (λ (t) (let ([arg-t (fresh-type-variable int float)])
                                 (hash 'l arg-t 'r arg-t)))]]

 [IfExpression [(fresh-type-variable)
                (λ (t) (hash 'test bool 'then t 'else t))]]
 [LiteralInt [int (no-child-types)]]
 [LiteralFloat [float (no-child-types)]]
 [VariableReference [(fresh-base-or-function-type) (no-child-types)]]
 )

(add-prop
 cish2-grammar
 choice-filters-to-apply
 [#f (
      features-enabled
      respect-return-position
      misc-constraints
      )])
