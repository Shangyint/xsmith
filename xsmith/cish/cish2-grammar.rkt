#lang racket/base

(provide cish2-grammar)

(require
 "../grammar-macros.rkt"
 "../core-properties.rkt"
 "cish2-utils.rkt"
 "../scope-graph.rkt"
 (only-in pprint [empty empty-doc])
 racr
 racket/random
 racket/class
 racket/dict
 )


(define-spec-component cish2-grammar)

(add-to-grammar
 cish2-grammar
 [Node #f ([precomment = empty-doc]
           [postcomment = empty-doc])]
 [Program Node ([declarations : Declaration * = (random 7)]
                [main : FunctionDefinition])]

 [Declaration Node ([liftdepth = 0]
                    [type]
                    [name])]
 [VariableDeclaration Declaration (Expression)]
 [FunctionDefinition Declaration ([params : FormalParam *]
                                  Block)]
 [FormalParam Node ([type]
                    [name = (fresh-var-name "arg_")])]


 [Statement Node ()]
 [NullStatement Statement ()]
 [Block Statement ([declarations : Declaration * = (random 2)]
                   [statements : Statement * = (add1 (random 4))])]
 [ExpressionStatement Statement (Expression)]
 [IfStatement Statement ([test : Expression]
                         [then : Statement])]
 [IfElseStatement IfStatement ([else : Statement])]
 [ReturnStatement Statement ()]
 ;[VoidReturnStatement ReturnStatement ()]
 [ValueReturnStatement ReturnStatement (Expression)]

 [LoopStatement Statement ([test : Expression]
                           [body : Statement])]
 [WhileStatement LoopStatement ()]
 [DoWhileStatement LoopStatement ()]
 [ForStatement LoopStatement ([init : Declaration]
                              [update : Expression])]

 [Expression Node ()]

 [AssignmentExpression Expression ([name]
                                   Expression)]
 [FunctionApplicationExpression Expression ([function : VariableReference]
                                            [args : Expression *])]
 [BinaryExpression Expression ([l : Expression]
                               [r : Expression])]
 [AdditionExpression BinaryExpression ()]
 [UnsafeAdditionExpression AdditionExpression ()]
 [SubtractionExpression BinaryExpression ()]
 [UnsafeSubtractionExpression SubtractionExpression ()]
 [MultiplicationExpression BinaryExpression ()]
 [UnsafeMultiplicationExpression MultiplicationExpression ()]
 [DivisionExpression BinaryExpression ()]
 [UnsafeDivisionExpression DivisionExpression ()]

 [IntOnlyBinaryExpression BinaryExpression ()]
 [ModulusExpression IntOnlyBinaryExpression ()]
 [UnsafeModulusExpression ModulusExpression ()]

 [ComparisonExpression BinaryExpression ()]
 [EqualityExpression ComparisonExpression ()]
 [GreaterThanExpression ComparisonExpression ()]
 [LessThanExpression ComparisonExpression ()]
 [LessOrEqualExpression ComparisonExpression ()]
 [GreaterOrEqualExpression ComparisonExpression ()]

 [IfExpression Expression ([test : Expression]
                           [then : Expression]
                           [else : Expression])]
 [LiteralInt Expression (val)]
 [LiteralFloat Expression (val)]
 [VariableReference Expression (name)]

 )

(add-prop cish2-grammar
          may-be-generated
          ;; abstract nodes
          [Declaration #f]
          [Statement #f]
          [ReturnStatement #f]
          [LoopStatement #f]
          [Expression #f]
          [BinaryExpression #f]
          [IntOnlyBinaryExpression #f]
          [ComparisonExpression #f]

          ;; Unsafe nodes should be generated by analysis transformations,
          ;; not random choice.
          [UnsafeAdditionExpression #f]
          [UnsafeSubtractionExpression #f]
          [UnsafeMultiplicationExpression #f]
          [UnsafeDivisionExpression #f]
          [UnsafeModulusExpression #f]
          )

(add-prop cish2-grammar
          depth-increase
          [Block (λ (n) (if (member (node-type (parent-node n))
                                    '(IfStatement
                                      IfElseStatement
                                      FunctionDefinition
                                      ForStatement
                                      WhileStatement
                                      DoWhileStatement))
                            (att-value 'ast-depth (parent-node n))
                            (add1 (att-value 'ast-depth (parent-node n)))))]
          ;; some nodes should never increase depth
          [ExpressionStatement (λ(n)0)]
          [AssignmentExpression (λ(n)0)]
          [Declaration (λ(n)0)])

(add-prop cish2-grammar
          fresh
          [IfElseStatement (hash
                            'then
                            (make-hole 'Block)
                            'else
                            (make-hole 'Block))]
          [AssignmentExpression
           (hash
            'name
            (let* ([choice* (random-ref (send this xsmith_reference-options!))]
                   [choice (if (procedure? choice*) (choice*) choice*)])
              (binding-name choice)))]
          [FunctionApplicationExpression
           (hash 'function (make-hole 'VariableReference)
                 ;; Make an empty args list which will be rewritten
                 ;; by fresh for VariableReference.
                 'args 0)]
          [VariableReference
           (hash 'name
                 (λ ()
                   (let* ([choice* (random-ref (send this
                                                     xsmith_reference-options!))]
                          [choice (if (procedure? choice*)
                                      (choice*)
                                      choice*)]
                          [parent (parent-node (current-hole))])
                     (when (and (ast-subtype? parent 'FunctionApplicationExpression)
                                (eq? (current-hole) (ast-child 'function parent)))
                       ;; Rewrite the function argument list to match the
                       ;; length required by the type we've chosen.
                       (let ([arg-children (create-ast-list
                                            (map (λ (x) (make-hole 'Expression))
                                                 (product-type-inner-type-list
                                                  (function-type-arg-type
                                                   (binding-type choice)))))])
                         (enqueue-inter-choice-transform
                          (λ ()
                            (rewrite-subtree
                             (ast-child 'args parent)
                             arg-children)))))
                     (binding-name choice))))]
          [VariableDeclaration
           (let* ([hole-name (ast-child 'name current-hole)]
                  [name (if (string? hole-name)
                            hole-name
                            (if (equal? (top-ancestor-node current-hole)
                                        (parent-node current-hole))
                                (fresh-var-name "global_")
                                (fresh-var-name "local_")))]
                  [hole-type (ast-child 'type current-hole)]
                  [type (if (and hole-type
                                 (not (and (ast-node? hole-type)
                                           (ast-bud-node? hole-type))))
                            hole-type
                            (fresh-concrete-var-type))])
             (hash 'name name
                   'type type))]
          [FunctionDefinition
           (let* ([p (parent-node current-hole)]
                  [main? (and (eq? (node-type p) 'Program)
                              (eq? (ast-child 'main p) current-hole))]
                  [hole-name (ast-child 'name current-hole)]
                  [name (if (string? hole-name)
                            hole-name
                            (if main?
                                "main"
                                (fresh-var-name "func_")))]
                  [hole-type (ast-child 'type current-hole)]
                  [type (if (and hole-type
                                 (not (and (ast-node? hole-type)
                                           (ast-bud-node? hole-type))))
                            hole-type
                            (if main?
                                (function-type (product-type '()) int)
                                (fresh-concrete-function-type)))]
                  [params (map (λ (t) (make-fresh-node 'FormalParam
                                                       (hash 'type t)))
                               (product-type-inner-type-list
                                (function-type-arg-type type)))])
             (hash
              'name name
              'type type
              'params params))]
          [LiteralInt (hash 'val (* (random 100)
                                    (if (equal? 0 (random 2))
                                        1
                                        -1)))]
          [LiteralFloat (hash 'val (* (random)
                                      (random 10)
                                      (if (equal? 0 (random 2))
                                          1
                                          -1)))]
          )

#;(add-prop cish2-grammar
          introduces-scope
          [Program #t]
          [FunctionDefinition #t]
          [Block #t]
          [ForStatement #t])
(add-prop cish2-grammar
          binder-info
          [Declaration (name type)]
          [VariableDeclaration (name type)]
          [FunctionDefinition (name type)]
          [FormalParam (name type)])
(add-prop cish2-grammar
          reference-info
          [VariableReference (read name)]
          [AssignmentExpression (write name)])
(add-prop cish2-grammar
          strict-child-order?
          [Program #t]
          [Block #t]
          [IfStatement #t]
          [IfExpression #t]
          [LoopStatement #t])
(add-prop cish2-grammar
          lift-predicate
          [FunctionDefinition #f]
          ;[FunctionDefinition (λ (n type) #f)]
          [Program (λ (n type) #t)]
          [Block (λ (n type) (not (function-type? type)))])
(add-prop cish2-grammar
          lift-type->ast-binder-type
          [#f (λ (type) (if (function-type? type)
                            'FunctionDefinition
                            'VariableDeclaration))])


#|
Type definitions are in cish-utils.rkt
|#

;; TODO - this property is wonky because it needs more info than I originally anticipated due to shortsightedness in wanting to design something easy to write.  It needs to take the node as well as its type, or maybe have an option to take its node.
(add-prop
 cish2-grammar
 type-info
 [#f [(error 'typing-base-node) (no-child-types)]]
 ;[Node [(error 'typing-node) (no-child-types)]]
 [Program [(fresh-type-variable)
           (λ (n t) (hash 'main (function-type (product-type '())
                                               int)
                          'declarations (λ (c) (fresh-type-variable))))]]

 ;[Declaration [(error 'typing-declaration) (no-child-types)]]
 [VariableDeclaration [(fresh-type-variable)
                       (λ (n t)
                         (let ([declaration-type-annotation (ast-child 'type n)])
                           (unify! t declaration-type-annotation)
                           (hash 'Expression
                                 declaration-type-annotation)))]]
 [FunctionDefinition [(function-type (product-type #f) (fresh-type-variable))
                      (λ (n t)
                        (let ([definition-type-annotation (ast-child 'type n)]
                              [f-type (function-type
                                       (fresh-type-variable)
                                       (fresh-type-variable))])
                          (unify! t definition-type-annotation)
                          (unify! t f-type)
                          (hash
                           'Block
                           (return-type (function-type-return-type f-type)))))]]

 [Statement [(error 'typing-statement) (no-child-types)]]
 ;[Statement [(fresh-type-variable (fresh-no-return) (return-type (fresh-type-variable))) (no-child-types)]]

 [NullStatement [(fresh-no-return) (no-child-types)]]
 [Block [(fresh-maybe-return)
         (λ (n t)
           (define statements (ast-children (ast-child 'statements n)))
           (define last-statement (car (reverse statements)))
           (define statement-dict
             (for/hash ([s (ast-children (ast-child 'statements n))])
               (values s
                       (if (eq? s last-statement)
                           t
                           (fresh-no-return)))))
           (for/fold ([dict statement-dict])
                     ([d (ast-children (ast-child 'declarations n))])
             (dict-set dict d (fresh-type-variable))))]]
 [ExpressionStatement [(fresh-no-return)
                       (λ (n t) (hash 'Expression (fresh-type-variable)))]]
 [IfStatement [(fresh-no-return)
               (λ (n t) (hash 'test bool
                              'then t))]]
 [IfElseStatement [(fresh-maybe-return)
                   (λ (n t) (hash 'test bool
                                  'then t
                                  'else t))]]
 [ReturnStatement [(error 'typing-non-value-return-statement) (no-child-types)]]
 [ValueReturnStatement [(return-type (fresh-type-variable))
                        (λ (n t)
                          (define rt (return-type (fresh-type-variable)))
                          (unify! t rt)
                          (hash 'Expression (return-type-type rt)))]]


 [LoopStatement [(fresh-maybe-return)
                 (λ (n t) (hash 'test bool
                                'body t))]]
 ;; WhileStatement
 ;; DoWhileStatement
 [ForStatement [(fresh-maybe-return)
                (λ (n t)
                  (let ([loop-var-type (fresh-type-variable)])
                    (hash 'test bool
                          'body t
                          'init loop-var-type
                          'update loop-var-type)))]]

 ;[Expression [(fresh-type-variable) (no-child-types)]]
 [Expression [(error 'typing-expression) (no-child-types)]]

 [AssignmentExpression [(fresh-type-variable)
                        (λ (n t) (hash 'Expression t))]]
 [FunctionApplicationExpression
  [(fresh-type-variable)
   (λ (n t)
     (define args-type (product-type #f))
     (define arg-nodes (ast-children (ast-child 'args n)))
     (define func-node (ast-child 'function n))
     (define arg-types (map (λ (c) (fresh-type-variable)) arg-nodes))
     (when (not (att-value 'is-hole? func-node))
       (unify! args-type (product-type arg-types)))
     (for/fold ([dict (hash 'function (function-type args-type t))])
               ([a arg-nodes]
                [t arg-types])
       (dict-set dict a t)))]]
 [AdditionExpression [(fresh-type-variable int float)
                      (λ (n t) (hash 'l t 'r t))]]
 [SubtractionExpression [(fresh-type-variable int float)
                         (λ (n t) (hash 'l t 'r t))]]
 [MultiplicationExpression [(fresh-type-variable int float)
                            (λ (n t) (hash 'l t 'r t))]]
 [DivisionExpression [(fresh-type-variable int float)
                      (λ (n t) (hash 'l t 'r t))]]

 [IntOnlyBinaryExpression [int
                           (λ (n t) (hash 'l int 'r int))]]

 [ComparisonExpression [(fresh-type-variable bool)
                        (λ (n t) (let ([arg-t (fresh-type-variable int float)])
                                   (hash 'l arg-t 'r arg-t)))]]

 [IfExpression [(fresh-type-variable)
                (λ (n t) (hash 'test bool 'then t 'else t))]]
 [LiteralInt [(fresh-type-variable int bool) (no-child-types)]]
 [LiteralFloat [float (no-child-types)]]
 [VariableReference [(fresh-base-or-function-type) (no-child-types)]]
 )

(add-prop
 cish2-grammar
 choice-filters-to-apply
 [#f (
      features-enabled
      misc-constraints
      )])
