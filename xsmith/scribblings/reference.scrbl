#lang scribble/manual
@; -*- mode: Scribble -*-
@;
@; Copyright (c) 2019 The University of Utah
@; All rights reserved.
@;
@; This file is part of Xsmith, a generator of highly effective fuzz testers.
@;
@; Redistribution and use in source and binary forms, with or without
@; modification, are permitted provided that the following conditions are met:
@;
@;   * Redistributions of source code must retain the above copyright notice,
@;     this list of conditions and the following disclaimer.
@;
@;   * Redistributions in binary form must reproduce the above copyright
@;     notice, this list of conditions and the following disclaimer in the
@;     documentation and/or other materials provided with the distribution.
@;
@; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
@; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
@; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@; ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
@; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
@; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
@; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
@; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
@; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
@; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
@; POSSIBILITY OF SUCH DAMAGE.

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@(require
"util.rkt"
(for-label
(except-in racket/base
           module)
xsmith
xsmith/racr-convenience

racket/contract/base
racket/dict

@; if racr had scribble documentation this would provide hyperlinks
@;racr
)
)

@title{Xsmith Reference}

@section{Stability}

Xsmith does not currently promise API stability between versions.

@section[#:tag "generated-rules"]{Auto-Generated att-rules and choice-rules}
Many attributes and choice-rules are auto-generated by Xsmith:

@bold{att-rules}

@itemlist[
@item{@racket['xsmith_is-hole?]

Accepts no arguments other than the node to call it on.
Returns @racket[#t] when called on a hole node, otherwise returns @racket[#f].

Example:
@racketblock[
(code:comment "Within the context of a choice method, this will return #t")
(att-value 'xsmith_is-hole? (current-hole))
]
}
@item{@racket['xsmith_find-descendants]

Accepts the node to call it on, then a predicate.
Returns a list of all descendant nodes that satisfy the predicate.

Example:
@racketblock[
(code:comment "This will return a list of all addition and subtraction nodes.")
(code:comment "It will not return any nodes that are subtypes, though!")
(att-value 'xsmith_find-descendants ast-node (Î» (n) (member (ast-node-type n)
                                                            '(AdditionExpression
                                                              SubtractionExpression))))
]
}
@item{@racket['xsmith_find-a-descendant]

Accepts the node to call it on, then a predicate.
Like @racket['xsmith_find-descendants], but it only returns one.
If no descendant matching the predicate is found, it returns @racket[#f].
It is mostly useful if you just want to know if there is any descendant matching a type, such as to determine whether to do an analysis based on the presence or absence of some feature.
}
@item{@racket['xsmith_resolve-reference-name]

Accepts the node to call it on and a name (as a @racket[string?]) to resolve.
Returns the @racket[binding] object for the name at the given node.
The lookup is done using the @seclink["scope-graph"]{scope graph model}.
If the name is not bound, an exception is raised.

Example:
@racketblock[
(att-value 'xsmith_resolve-reference-name n (ast-child 'name n))
]

The main use of this is to do analyses where you need to look up the declaration node that a reference refers to.
The @racket[binding] object returned by this function contains a reference to that node.
}
@item{@racket['xsmith_ast-depth]

Accepts the node it is called on, and no other arguments.
Returns the tree depth at that node.
Determined by @racket[depth-increase].

Example:
@racketblock[
(att-value 'xsmith_ast-depth n)
]
}
@item{@racket['xsmith_type]
This attribute takes no arguments (besides a @(racr) node) and returns the type (@racket[type?]) of that node.
Note that the type of the node may be a not-yet-concretized type variable.

@racketblock[
(att-value 'xsmith_type n)
]
}
]

@bold{choice-rules}

@itemlist[
@item{@racket['xsmith_get-reference!]
This is a choice method that can be used when creating a reference node.
If no binding of the appropriate type for the current node is in scope, this method will cause a fresh appropriate definition to be lifted into a node that can hold definitions.
It returns a @racket[string?] of the reference name.

Example:
@racketblock[
(att-value 'xsmith_type (current-hole)) (code:comment "-> (fresh-type-variable int bool)")

(code:comment "This will return the name of a variable in scope")
(code:comment "that has type int or type bool.")
(code:comment "It may make a new definition node to do that.")
(define name (send (current-hole) xsmith_get-reference!))
]

Note that the reference is @emph{choosing} one of the possible types (via @racket[concretize-type]).
Probably you are using this in a @racket[fresh] method to initialize a node.
So you will want to put that name in the node.

Generally you don't need to do this manually, however.
Nodes with the @racket[reference-info] property marked will automatically have their name fields initialized, and nodes with the @racket[binder-info] property marked will automatically have their name and type fields initialized.
}
]


Node type names, attribute names, and choice rule names are just symbols, so they are not hygienic.
The names of symbols used or defined by the xsmith library start with @verb{xsmith} or @verb{_xsmith}, so don't tread on those namespaces.


@section{Forms for Defining a Grammar and Its Attributes}

@defform[(define-spec-component component-name)]{
Defines a spec component.  Spec components include information about a language grammar and attributes, and can be combined to generate an xsmith fuzzer.  You add grammar productions with @racket[add-to-grammar], you add properties with @racket[add-prop], and you can add att-rules and choice-rules with @racket[add-att-rule] and @racket[add-choice-rule], respectively.  Spec components are combined with @racket[assemble-spec-components].

Example:
@racketblock[
(define-spec-component my-spec-component)
(code:comment "Now use add-to-grammar, add-prop, etc.")
(code:comment "Then use my-spec-component in assemble-part-specs.")
]
}

@defform[(assemble-spec-components spec-name
                                   maybe-properties
                                   spec-component ...)
#:grammar [(maybe-properties (code:line)
                             (code:line #:properties list-of-properties))]
          @;[list-of-properties (property ...)]
          ]{

Combines spec components and generates a @(racr) specification.

Defines @racket[spec-name] as a @(racr) specification.

Defines @verb{<spec-name>-generate-ast} as a function.  The function accepts the name of a grammar production as a symbol and produces a random tree starting from a fresh node of that nonterminal.  Essentially, given the name of the top-level program node, this function generates a random program.

Various att-rules are automatically defined within the spec, see @secref{generated-rules}.

Properties (defined with @racket[define-property]) are used to derive more @(racr) att-rules as well as Xsmith choice-rules.
Each property may have a transformer function that alters other properties, att-rules, or choice-rules.
All properties referenced within a spec-component are used to generate att-rules and choice-rules, as well as any properties specified in the @racket[maybe-properties] list.
Unless values for that property have also been specified within a spec component, properties in the @racket[maybe-properties] list will only be able to generate rules based on the default value for the property.

Example:
@racketblock[
(assemble-spec-components
 my-spec
 #:properties (depth-increase fresh wont-over-deepen introduces-scope)
 my-spec-component
 my-other-spec-component
 )
(code:comment "Now `my-spec` is defined as a RACR spec,")
(code:comment "and `my-spec-generate-ast` is defined as a function which")
(code:comment "accepts a symbol argument representing the name of an AST node.")
]
}

@defform[(add-to-grammar spec-component grammar-clause ...)
#:grammar [(grammar-clause (node-name parent-name (field ...) maybe-prop ..))
           (parent-name identifier #f)
           (field name/type-id
                  (name/type-id maybe-type-id maybe-kleene-star maybe-init-expr))
           (maybe-type-id (code:line)
                          (code:line : type-name))
           (maybe-kleene-star (code:line) *)
           (maybe-init-expr (code:line) (code:line = init-expr))
           (maybe-prop (code:line #:prop prop-id prop-val))]]{

Adds grammar productions to @racket[spec-component].

@racket[node-name] will be the name of the grammar production in @(racr).
@racket[parent-name] is either the name of the parent grammar production or @racket[#f].

Names for the node and fields are limited to alphabetic characters.  You may want to use camelCase style names since kebab-style or snake_style names due to this limitation.

Fields are then specified.
Each nonternimal inherits all fields of its parent nodes.
A field has a name, a type, an optional kleene star, and an optional initialization expression.
The type of each field is the name of the nonterminal that it must be or @racket[#f] for fields that may contain arbitrary Racket values.
A field name may be the same as the type, in which case the type does not need to be specified.
If a type is not specified and the name does not match the name of a nonterminal, then the type #f is used.
If the optional kleene star is supplied, the field will be a list field.
If a kleene star is provided for a non-false type, the name and type must be specified separately.

The @racket[init-expr] for each field specifies a default value for the field.
When a node is generated, each @racket[init-expr] is evaluated unless a non-default value is supplied to the generating function.
If no @racket[init-expr] is supplied, the following defaults are used:

@itemlist[
@item{For false types, @racket[#f].}
@item{For nonterminal types, a hole node of the appropriate type.}
@item{For fields with a kleene star, an empty list.}
]

For nodes with a kleene star, @racket[init-expr] may return a list or a number.
If a number is provided, the default value is a list of that many of the non-kleene-star default value.

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [Expression #f ()]
 [LiteralInt Expression (v = (random 1000))]
 [AdditionExpression Expression ([left : Expression] [right : Expression])]
 [SumExpression Expression ([addends : Expression * = (random 5)])])
]

The example defines a piece of a grammath that includes some kinds of expressions.
When a @verb{LiteralInt} expression is generated, it's @verb{v} field will be populated with a random number.
Since the @racket[random] expression is evaluated for each fresh @verb{LiteralInt}, they will (probably) receive different values for @verb{v}.
When an @verb{AditionExpression} node is generated, it will be populated with an @verb{Expression} hole node for each of its @verb{left} and @verb{right} fields.
When a fresh @verb{SumExpression} is generated, its @verb{addends} field will be populated with a list of zero to four @verb{Expression} hole nodes.
}

@defform[(add-att-rule spec-component rule-name rule-clause ...)
#:grammar [(rule-clause (nonterminal-name rule-function))]]{
Adds a @(racr) attribute rule to the spec-component.
The format for each rule is similar to that required by @(racr)'s @verb{ag-rule} form.

Example:
@racketblock[
(add-att-rule
 my-spec-component
 interp
 [LiteralInt (Î» (n) (ast-child 'v n))]
 [AdditionExpression (Î» (n) (+ (att-value 'interp (ast-child 'left n))
                               (att-value 'interp (ast-child 'right n))))]
 [SumExpression (Î» (n) (apply + (map (Î» (c) (att-value 'interp c))
                                     (ast-children (ast-child 'addends n)))))])
]
}

@defform[(add-choice-rule spec-component rule-name rule-clause ...)
#:grammar [(rule-clause (nonterminal-name rule-function))]]{
Adds an Xsmith choice-rule to the spec-component.

Xsmith creates a choice object class for each node type in the specification grammar, following the same class hierarchy that AST nodes themselves do.  Choice objects are created every time Xsmith fills in a hole node.  One choice object is created for every node type that is legal to use in filling the hole.  Choice objects are then filtered according to the @racket[choice-filters-to-apply] property, and then the @racket[choice-weight] property of the remaining choice objects is used to determine the probability of choosing each one.  When a choice object is selected, its @racket[fresh] property is used to generate a new AST node of its type.  If all choices are eliminated, an exception is raised with a message stating which filter step invalidated each potential choice.

Choice rules are methods on the choice objects.  Some choice rules are used by @racket[choice-filters-to-apply] to filter choices.  Other choice rules may be used by those filters or in the body of the @racket[fresh] property as helper methods.  While most information about the AST and the current choice are probably computed using att-rules, information about choosing a specific node type to fill in an abstract hole (such as an expression hole which may be filled with many different types of expressions) are computed using choice rules.

Choice rules are methods in Racket's class system and therefore have the @racket[this] macro available for use in their bodies to access other methods (eg. with the @racket[send] macro).
Choice rules also have the @racket[current-hole] macro available within their body so that they can query attributes of the @(racr) AST being elaborated (eg. with @verb{att-value} to access att-rules and @verb{ast-parent} to inspect other nodes in the AST).

Since choice rules are methods in Racket's @racket[class] system, they must be defined with a literal @racket[lambda] (with no parameter for the implicit @racket[this] argument).  If a method needs to modify state (such as to cache the computation of available references of the appropriate type), I would normally recommend the âlet-over-lambdaâ pattern, but that is not allowed in this case.  To make up for this, I recommend using @racket[make-weak-hasheq] to hold the state, using the @racket[this] object as a key.


This is a poor example, but it demonstrates how att-rules and choice-rules can be used together to help make choices:
@racketblock[
(add-choice-rule
 my-spec-component
 my-weight-helper
 [#f 7]
 [AdditionExpression
  (Î» () (if (att-value 'my-helper-att-rule (current-hole))
            20
            5))])
(add-prop
 my-spec-component
 choice-weight
 [#f (send this my-weight-helper)])
]

}

@defform[(add-prop spec-component prop-name prop-clause ...)
#:grammar [(prop-clause (nonterminal-name prop-value))]]{
Adds property values to the spec-component.

Since property transformers are macros that may accept arbitrary domain-specific syntax, the grammar of prop-value varies for each property.
}


@defform[(current-hole)]{
Within the body of a choice-rule, @racket[(current-hole)] returns the hole node being considered for replacement.
This allows choice-rules to query att-rule attributes of the grammar.

Elsewhere it raises a syntax error.
}

@defform[(make-hole hole-type-expression)]{
Within the context of a spec component (eg. in the body of @racket[add-att-rule], @racket[add-prop], @racket[add-to-grammar], etc), @racket[make-hole] is a function to generate a hole of a given type.

For example, to make a hole node that will eventually be replaced with some type of @verb{Expression} node:
@racketblock[(make-hole 'Expression)]

This function is essentially used by @racket[add-to-grammar] as the default value for grammar fields with nonterminal types that lack an init-expr.

Outside of a spec component context, it raises a syntax error.
}

@defform[(make-fresh-node node-type-expression optional-field-value-dict)]{
Within the context of a spec component (eg. in the body of @racket[add-att-rule], @racket[add-prop], @racket[add-to-grammar], etc), @racket[make-fresh-node] is a function to generate a fresh node of the given type.
Construction of the new node is guided by the @racket[fresh] property.

For example, to generate a fresh @verb{AdditionExpression} node, specifying values for some of its fields:
@racketblock[(make-fresh-node 'AdditionExpression
                               (hash 'left (make-fresh-node 'LiteralInt
                                                            (hash 'v 5))))]
}

@section{Custom Properties}

Properties are used to create domain-specific languages or terse declarative syntax for specifying att-rules and choice-rules.
Custom properties are probably only useful for shared infrastructure for multiple languages (perhaps with the exception of @racket[define-non-inheriting-rule-property]).


@defform[(define-property name
                          maybe-dups
                          maybe-reads
                          maybe-rewrites
                          maybe-appends
                          maybe-transformer)
#:grammar [(maybe-dups (code:line)
                       (code:line #:allow-duplicates? literal-bool))
           (maybe-reads (code:line)
                        (code:line #:reads transformer-arg-spec ...))
           (maybe-rewrites (code:line)
                           (code:line #:rewrites transformer-arg-spec ...))
           (maybe-appends (code:line)
                          (code:line #:appends transformer-arg-spec ...))
           (maybe-transformer (code:line)
                              (code:line #:transformer transformer-function))
           (transformer-arg-spec (property prop-name)
                                 (att-rule rule-name)
                                 (choice-rule rule-name)
                                 (grammar))
           ]]{
Defines a property for use with @racket[add-prop].

Properties can have a transformer function that produce att-rules, choice-rules, or other property values.
Property transformers can read the values set for the property by @racket[add-prop], and optionally the values of other properties as well.
Not all properties must have a transformer -- some properties may just be a single place to store information that is used by (multiple) other properties.

The transformer function accepts a dictionary mapping grammar node names (as symbols) to the syntax objects from the right-hand-side of @racket[add-prop] uses for each property that it reads.
The transformer function must return a list of dictionaries mapping grammar node names (as symbols) to syntax objects for the properties, att-rules, and choice-rules that it writes.

Property transformers are run during @racket[assemble-spec-components] in an order determined by the read/write dependencies among the properties.
Appending goes before rewriting, which goes before reading.

If a property appends (using the #:appends keyword) to a property or rule, its return dictionary will be appended to the existing dictionary for that property/rule.
This allows a property or rule to be specified in part by the property that appends and in part by another property or the user.
If an appended rule (or property that disallows multiple values) ends up with two values for any node, an error is raised.

If a property rewrites (using the #:rewrites keyword) to a property or rule, its return dictionary replaces any previous dictionary for that property/rule.
Rewriting a property also automatically implies reading that property.
A property or rule may only be rewritten by one property transformer.

Example showing the arguments and return type needed by transformers:
The transformer argument order is its own property, then #:reads dictionaries in the order declared, then #:rewrites dictionaries in the order declared.
The transformer return order is #:rewrites dictionaries in the order declared then #:writes dictionaries in the order declared.
@racketblock[
(define-property my-property
  #:reads (property a) (property b)
  #:rewrites (property c)
  #:appends (att-rule d) (choice-rule e)
  #:transformer
  (Î» (this-prop-dict prop-a-dict prop-b-dict prop-c-dict)
    (code:comment "compute output dictionaries...")
    (list dict-for-c dict-for-d dict-for-e)
    ))
]

The syntax object value for a property can be anything, since property transformers define the grammar and semantics of properties.

The syntax object value for @verb{att-rules} and @verb{choice-rules} should be a syntax object specifying a function (IE a @racket[lambda]).
@verb{att-rules} may be any syntax that evaluates to a function (so you may return an identifier that references a function or an expression that computes a function such as let-over-lambda), but choice-rule syntax is provided to Racket's @racket[class] macro, which requires literal @racket[lambda] forms.

@; TODO - internal properties read the grammar, but the API for that is horrible.
@;The syntax object value for grammar productions when @verb{(grammar)} is read is a syntax object of class @racket[grammar-clause].

Dictionaries may or may not contain an entry for each nonterminal in the grammar.
@;(Except the grammar dictionary which always contains all nonterminals.)
A dictionary may even be empty.

In addition to nonterminals, each dictionary may include a mapping for the value @racket[#f], which will define a default value used for the (super secret) parent node that @racket[assemble-spec-components] defines.
If nothing is specified for #f, att-rules and choice-rules will have a default which errors, providing a helpful error message.

If the @racket[#:allow-duplicates?] argument is supplied and is @racket[#t], then @racket[add-prop] may be used more than once for the property for the same node, and the syntax object in the dictionary for the property will be a syntax list of the syntax objects specified in the various @racket[add-prop] calls.
But by default only one use of @racket[add-prop] is allowed per property per node type, and the syntax object in the dict is the single syntax object from the one call.

Here is a simple example that basically desugars straight to an att-rule with a default:

@racketblock[
(define-property strict-child-order?
  #:appends (att-rule _xsmith_strict-child-order?)
  #:transformer
  (Î» (this-prop-info)
    (define _xsmith_strict-child-order?-info
      (hash-set
       (for/hash ([(n v) (in-dict this-prop-info)])
         (values n (syntax-parse v [b:boolean #'(Î» (n) b)])))
       #f #'(Î» (n) #f)))
    (list _xsmith_strict-child-order?-info)))
]

The rationale for this example property is to:
@itemlist[
@item{Allow values to be specified by just @racket[#t] or @racket[#f], rather than @racket[(Î» (n) #t)]}
@item{To implicitly provide a default value to the root node (@racket[#f]).}
]

For more realistic examples of properties, see the file @verb{private/core-properties.rkt} in the Xsmith implementation.
Generally they are big, hairy macros.

}

@defform[(define-non-inheriting-rule-property property-name
                                              rule-type
                                              maybe-rule-name
                                              default-value
                                              maybe-transformer)
#:grammar [(maybe-rule-name (code:line)
                            (code:line #:rule-name rule-name))
           (default-value (code:line #:default default-expr))
           (maybe-transformer (code:line)
                              (code:line #:transformer transformer-func))]]{
Defines a property that generates an att-rule or a choice-rule that does NOT inherit its implementation from its superclass.

@racket[rule-type] must be either @verb{att-rule} or @verb{choice-rule}.

@racket[rule-name] defaults to @racket[property-name], but you can make it give the rule a different name than the property.

@racket[default-expr] is the default value of the property.  Any nonterminal that does not have a different value specified gets this one.

@racket[transformer-func] is an optional transformer to transform the value.
It is not called with a dictionary like the transformers of @racket[define-property], but rather it receives each value individually.
This allows a small amount of sugar.
Note that the value supplied as the @racket[default-expr] is also transformed by the @racket[transformer-func] when it is supplied.
When no @racket[transformer-func] is supplied, values are passed through literally.

Example:
@racketblock[
(define-non-inheriting-rule-property
  some-bool-flag
  att-rule
  #:default #f
  #:transformer (syntax-parser [#f #'(Î» () #f)]
                               [#t #'(Î» () #t)]))
(add-to-grammar
 a-spec-component
 [A #f ()]
 [B A ()]
 [C B ()])
(add-prop
 a-spec-component
 some-bool-flag
 [A #t]
 [C #t])
]

Normally @verb{B} would inherit a method from @verb{A} when none was specified for it.
But in this case it inherits the default (@racket[#f]).
When a user tries @verb{(att-value 'some-bool-flag <node-of-type-B>)} it will return @racket[#f], not @racket[#t].
}


@;@subsection{Helpers for creating properties}
@;
@;TODO - the APIs in this section are not very good.  Frankly I would like to rewrite them all.  Also, I don't think this section is important for a first version.  So I'm considering commenting the whole section out.
@;
@;@defform[#:kind "syntax class" #:id grammar-clause grammar-clause]{
@;This is a syntax class used for parsing grammar clauses.  If you parse one with @racket[syntax-parse], you will have access to the following fields:
@;
@;@itemlist[
@;@item{@verb{node-name} - the node name as an identifier}
@;@item{@verb{parent} - the parent node name as an identifier or @racket[#f] (as syntax, not as a bare @racket[#f]) if the node has no parent.}
@;@item{@verb{component ...} - a list of @racket[grammar-components]}
@;]
@;
@;TODO - (properties and the grammar) should this be in the public interface?  Yes if I allow properties to change the grammar, but otherwise I'm not sure.  For reading, it would probably be easier to get a dict full of a struct with: node name, chain of parent nodes, field list (of grammar-node-field-structs).  It will also be faster if I construct that once, because in various properties I am reconstructing some of that info multiple times.
@;
@;Example:
@;@racketblock[
@;(syntax-parse grammar-stx
@;  [x:grammar-clause
@;   (code:comment "This basically reconstructs it.")
@;   #'(x.node-name x.parent (x.component ...))])
@;]
@;}
@;@defform[#:kind "syntax class" #:id grammar-component grammar-component]{
@;This is a syntax class used for parsing the fields of @racket[grammar-clause]s.
@;If you parse one with @racket[syntax-parse], you will have access to the following fields:
@;@itemlist[
@;@item{@verb{name} - the field name as an identifier}
@;@item{@verb{type} - optional: the field type as an identifier if there is one, otherwise @racket[#f] (IE use @racket[attribute] to check if it is present).}
@;@item{@verb{kleene-star} - optional: literal @verb{*} character as an identifier if the field is a list type, otherwise @racket[#f] (IE use @racket[attribute] to check if it is present).}
@;@item{@verb{init-expr} - optional: syntax object for the initial expression if present, otherwise @racket[#f] (IE use @racket[attribute] to check if it is present).}
@;]
@;
@;TODO - the name should be changed to grammar-field or grammar-clause-field or something.
@;
@;TODO - (properties and the grammar) should this be in the public interface?  As with @racket[grammar-clause], I think it should only if properties can add to the grammar.  As with the TODO comment in @racket[grammar-clause].
@;}
@;
@;@defthing[grammar-clause->parent-chain any/c]{
@;TODO - (properties and the grammar) this should probably not be in the public interface.
@;
@;In general I should provide better ways to inspect the grammar in property transformers, but I haven't needed them yet...
@;}
@;
@;@defproc[(grammar-node-name->field-info-list [name symbol?] [grammar-clause-hash any/c])
@;         (listof/c grammar-node-field-struct?)]{
@;This function should be called with a node type name and the grammar object given as an argument to a property transformer that reads the grammar.
@;
@;It returns a list of structs containing information about the node's fields (including fields inherited from super node types).
@;
@;TODO - (properties and the grammar) this should probably not be in the public interface
@;}
@;
@;@defstruct[grammar-node-field-struct
@;           ([name symbol?]
@;            [type (or/c symbol? #f)]
@;            [kleene-star? boolean?]
@;            [init-expr syntax?])
@;           #:omit-constructor]{
@;The struct type in the list returned by @racket[grammar-node-name->field-info-list].
@;
@;TODO - (properties and the grammar) Properties asking to read the grammar should get a dict full of grammar clause structs that include a list of these.
@;}



@section{Scope Graph Functions}

This section describes the API to the @seclink["scope-graph"]{Scope Graph} model of binding.

@defstruct[binding ([name string?]
                    [ast-node ast-node?]
                    [type type?]
                    [def-or-param (or/c 'definition 'parameter)])
                   #:omit-constructor]{
Struct for binding information of nodes that create bindings.

Notably this is returned by the att-rule @rule[xsmith_resolve-reference-name].

The @racket[ast-node] field is the grammar node containing the definition of @racket[name].
The @racket[def-or-param] field is there to distinguish names that are bound as function parameters vs names that are bound as (local or global) definitions.

Probably all you need to do with this, though, is get the @racket[name] field and stuff it in the name field of your definition nodes in the @racket[fresh] method.
}

@defparam[current-well-formedness-regexp r regexp?
          #:value #px"rp*i?d"]{

For most languages you probably don't need to fuss with this.

When the @rule[xsmith_resolve-reference-name] attribute is used or when Xsmith searches for a valid reference with @rule[xsmith_get-reference], this regexp determines valid scope-graph resolution paths.
The path elements (reference, parent, import, definition) are turned into characters (r, p, i, and d respectively).
If the path from reference to definition matches this regexp, it is valid.
If two definitions have the same name and paths from a reference to both definitions are valid, the definition that is in scope for the reference is determined by @racket[current-path-greater-than].

Because Xsmith doesn't currently support import elements at all, modifying this regexp is somewhat of a moot point.

}

@defparam[current-path-greater-than comparator
         (-> (listof/c (or/c 'reference 'parent 'import 'declaration))
             (listof/c (or/c 'reference 'parent 'import 'declaration))
             any/c)]{

If there are two valid resolution paths (determined by @racket[current-well-formedness-regexp]) for a name, this comparator determines which path is chosen.
The comparator must return a non-false value if the left operand is greater than the right, otherwise @racket[#f]
The greatest path is chosen.

By default the comparator walks down the paths, comparing each element.
A path is greater than another if its first differing element is greater.
From least to greatest, path elements are @racket['reference], @racket['parent], @racket['import], @racket['declaration].

For most languages you probably don't need to fuss with this.
}

@;@subsection{scope-graph.rkt -- other things provided but that maybe aren't part of the public interface}
@;@itemlist[
@;@item{resolve-reference -- used by the resolve-reference attribute}
@;@item{visible-bindings -- used by the xsmith_visible-bindings attribute}
@;@item{scope -- struct used by basically all of the functions, but should be invisible to end-user}
@;@item{reference -- struct used internally like scope}
@;@item{module -- struct that I made for paths that include imports, but I haven't actually used that yet, so it is just languishing...}
@;]



@section{Core Properties}

These properties are available for specification on Xsmith grammars.
Many of them define or modify the behavior of core functionality, such as @racket[fresh] modifying how fresh program nodes are instantiated, or @racket[type-info] defining a language's type rules.

Many are optional, but for any language at all you probably need to use @racket[type-info] and @racket[may-be-generated].
Additionally, for any language with variables you need @racket[binder-info] and @racket[reference-info].
Next, the @racket[fresh] property will likely become necessary for a few fields that Xsmith can't infer.
Then the most important of the truly optional properties is likely @racket[choice-weight].




@defform[#:kind "spec-property" #:id may-be-generated may-be-generated]{
Acceptable values for this property are @racket[#t] or @racket[#f], and the default is @racket[#t].

If may-be-generated is false, the node is not added to the list of possibile choices to replace an appropriate AST hole.
It is useful to set it to false for abstract node types or for specialized node types that are meant to be swapped in only after a full tree is generated, such as by a later analysis to determine validity of an unsafe operation.
This property is NOT inherited by subclasses.

Example:
@racketblock[
(add-prop
 my-spec-component
 may-be-generated
 (code:comment "Expression is abstract and should not be instantiated,")
 (code:comment "only AdditionExpression, SubtractionExpression, etc.")
 [Expression #f]
 (code:comment "Only safe addition expressions should be generated,")
 (code:comment "but maybe a later pass after generation swaps some")
 (code:comment "safe addition expressions for unsafe ones after analysis.")
 [UnsafeAdditionExpression #f])
]

@; TODO - should I rename this to `abstract` (and flip its boolean interpretation)?  For most uses that probably makes sense.  Or better yet, perhaps I should add a separate `abstract` property that implies that it may not be generated, but also makes sure the node never ends up in the tree by any means.  As it is Cish uses nodes that may not be generated but may be added in a second pass (the unsafe math nodes).
}



@defform[#:kind "spec-property" #:id type-info type-info]{

This property is used to specify the type system used by the generator.
You should specify a type system even for dynamically typed languages so that programs don't just crash with dynamic type errors.

Example:
@racketblock[
(define int (base-type 'int))
(define float (base-type 'float))
(define bool (base-type 'bool))
(add-prop
 my-spec-component
 type-info
 [AdditionExpression [(fresh-type-variable int float)
                      (Î» (n t) (hash 'l t 'r t))]]
 [EqualityExpression [bool
                      (Î» (n t)
                        (define arg-type (fresh-type-variable))
                        (hash 'l arg-type 'r arg-type))]]
 [Lambda [(function-type (fresh-type-variable) (fresh-type-variable))
          (Î» (n t) (hash 'arg (function-type-arg-type t)
                         'Expression (function-type-return-type t)))]])
]

The property is two armed.

The first part is the type (or partially-constrained type variable) that the given node can inhabit.  The expression given is evaluated fresh every time a node is type checked or considered for generation.

The second part is a function that takes a node, its type, and must return a dictionary mapping its children nodes to types.  The dictionary keys may be the node objects of the node's children OR the symbol of the field name the child inhabits.  For kleene-star children, use their node unless they all should receive the same type.
}




@defform[#:kind "spec-property" #:id fresh fresh]{
This property determines how fresh nodes are constructed (by the @racket[make-fresh-node] function).

Acceptable values for this property are expressions which produce a @racket[dict?] object, or expressions which produce a function of type (-> dict? dict?).  Keys of the dictionary must be field names of the node being generated.  The values in the dictionary are used to fill node fields of the appropriate name.  Any field whose name is not in the dictionary will be filled by evaluating the default init-expr defined in the grammar (via @racket[add-to-grammar]).

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [Expression #f ()]
 [LiteralInt Expression (v = (random 1000))]
 [AdditionExpression Expression ([left : Expression] [right : Expression])])
(add-prop
 my-spec-component
 fresh
 (code:comment "Make AdditionExpressions always be generated with a literal 7 argument.")
 [AdditionExpression (hash 'left (make-fresh-node LiteralInt (hash 'v 7)))])
]

This is useful for fields that must be determined together.  For examlpe, a function call needs the function name and the number of arguments to be chosen together rather than independently.

As with all choice-rules, @racket[this] and @racket[current-hole] are available for use in expressions, which you may want to do for eg. accessing available bindings or mutable information connected to the choice object.

If the result is a procedure instead of a dictionary, that procedure must accept and return a dictionary.  It is called with a dictionary that is empty unless the node being created is the result of lifting a definition.  In that case it will have the appropriate name and type fields with the name and type chosen by the lifting mechanism.  In the case of lifting a definition, the name and type fields in the return dictionary are ignored.  This procedure option is allowed because your fresh expression may need access to the name or type to determine the values of other fields.  If a definition node only has a name and type field then a fresh property is unnecessary when lifting, and if lifting is the only way you generate definitions then fresh properties or initializers for definition nodes are unnecessary.

If the value for a field (IE values inside the result dictionary) is a procedure, it will be called with 0 arguments.  This allows the fresh property to provide a default value that is not evaluated when @racket[make-fresh-node] is called with an appropriate value.

}




@defform[#:kind "spec-property" #:id choice-weight choice-weight]{
This property determines the probability that different kinds of nodes will be chosen.  When choices have been filtered (based on @racket[choice-filters-to-apply]), one of the remaining choices is chosen at random with probability (choice-weight / sum-of-choice-weights).

The expression provided as the choice weight will be evaluated in the context of a method call, so @racket[this] and @racket[current-hole] are available.

Choice weights should be positive integer values.  The default weight is 10 unless set explicitly.

Example:
@racketblock[
(add-prop
 my-spec-component
 choice-weight
 (code:line "The default choice weight.")
 [#f (Î» () 10)]
 (code:line "Generate more AdditionExpressions")
 [AdditionExpression 20]
 [MultiplicationExpression 15]
 (code:line "Generate fewer SumExpressions")
 [SumExpression 5])
]
}



@defform[#:kind "spec-property" #:id depth-increase depth-increase]{
This property defines the @rule[xsmith_ast-depth] non-inheriting att-rule.

The property accepts an expression which much evaluate to a function of one argument (the @(racr) AST node) which returns a truthy value for nodes which increase the depth of the AST and #f otherwise.  The default is @racket[(Î» (n) #t)].
This property is NOT inherited by subclasses.

This is useful to allow node re-use.  For example, the body of an @verb{if} or @verb{for} statement might be a block and have the same semantics, but you might want a block inside an @verb{if} to only be considered a depth increase of 1, not 2.

Example:
@racketblock[
(define no-depth-if-body-is-block
  (Î» (n) (if (node-subtype? (ast-child 'body n) 'Block) 0 1)))
(add-prop
 my-spec-component
 depth-increase
 [IfStatement no-depth-if-body-is-block]
 [ForStatement no-depth-if-body-is-block])
]
}

@defform[#:kind "spec-property" #:id wont-over-deepen wont-over-deepen]{
The default for this property is probably what you want, so probably just be sure to add this to the extra #:properties flag of @racket[assemble-part-specs].

But if you want to set it:

The property accepts expressions which will evaluate to booleans (IE anything but only #f is false...), which are evaluated if the choice is made at the point where the AST is at it maximum depth.  A true value means that the choice is acceptable, false otherwise.  The default is computed by checking whether a node includes AST-node-typed fields.  If it does not it is considered atomic and therefore acceptable to choose when the AST is already at its maximum depth.
}


@defform[#:kind "spec-property" #:id binder-info binder-info]{
This property is used to mark nodes that define bindings.
The property consists of a length-3 list.
The first two are field names, one for the name of the field that stores the binding name, one for the name of the field that stores the binding type.
The last field is either @verb{definition} or @verb{parameter}, reflecting whether the binding is a function parameter.
This is used by some Xsmith analyses about higher order values.

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [Definition #f (name type Expression)]
 [Reference #f (name)])
(add-prop
 my-spec-component
 binder-info
 [Definition (name type definition)])
]
}
@defform[#:kind "spec-property" #:id reference-info reference-info]{
This property marks nodes that are reference nodes.  The argument for the property is a list containing:

@itemlist[
@item{The identifier @verb{read} or the identifier @verb{write}, indicating whether the reference reads or writes the variable}
@item{The name of the field that stores the reference name (as an identifier).}
]

Example:
@racketblock[
(add-prop
 my-spec-component
 reference-info
 [Reference (read name)])
]
}

@defform[#:kind "spec-property" #:id binding-structure binding-structure]{
This property is used on nodes that can have binders as children.
It determines the visibility of those binders to their siblings.
Options are @racket['serial] (like @verb{let*} in scheme), @racket['parallel] (like @verb{let} in scheme), and @racket['recursive] (like @verb{letrec} in scheme).

If the property is not specified, @racket['serial] is assumed and used as a default.

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [Let #f ([definitions : Definition *] Expression)]
 [Letstar #f ([definitions : Definition *] Expression)]
 [Letrec #f ([definitions : Definition *] Expression)]
 )
(add-prop
 my-spec-component
 binding-structure
 [Let 'parallel]
 (code:comment "Letstar we can leave blank if we want because serial is the default.")
 [Letrec 'recursive])
]
}


@defform[#:kind "spec-property" #:id strict-child-order? strict-child-order?]{
Specifies that a node's children are guaranteed by the language to have a strict evaluation order.
The default is false.
This property is used to determine whether nodes have a dependency in their read/write/io effect conditions.
(Those conditions are set by the @racket[io] and @racket[reference-info] properties.)

Setting this property is unnecessary, but using it allows more liberal use of references, mutation, and io effects.

Example:
@racketblock[
(add-prop
 my-spec-component
 strict-child-order?
 (code:comment "Most languages have some sort of sequential construct, like a block")
 [Block #t])
]
}


@defform[#:kind "spec-property" #:id io io]{
Used to specify that a node has some kind of IO effect, such as printing or reading a volatile variable.

Until and unless I make something better, this should also be used for any form that mutates some kind of higher-order object.
For example, setting a field in a mutable record.

Example:
@racketblock[
(add-prop
 my-spec-component
 io
 [Print #t]
 [SetRecordField #t])
]
}


@defform[#:kind "spec-property" #:id lift-predicate lift-predicate]{
This property specifies a predicate for whether a definition of a given type can be lifted to a node.

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [Let #f ([definitions : Definition *] Expression)]
 [Letstar #f ([definitions : Definition *] Expression)]
 [Letrec #f ([definitions : Definition *] Expression)]
 )
(add-prop
 my-spec-component
 lift-predicate
 (code:comment
  "Allow any definition type to be lifted into the top level of a program.")
 [Program (Î» (n type) #t)]
 (code:comment
  "Lifting a definition to Lambda's formal parameter list would require changing all calls.")
 [Lambda (Î» (n type) #f)]
 (code:comment
  "Allow local variables to be lifted, except make all functions top-level.")
 [Let (Î» (n type) (not (function-type? type)))])
]
}

@defform[#:kind "spec-property" #:id lift-type->ast-binder-type
lift-type->ast-binder-type]{
If you have more than one binding node in your language (IE via @racket[binder-info]) you must specify this property.
This property should be defined once for the base node (#f).
It is a mapping from the type of a desired definition (eg. int, float, int -> int, ...) to the AST node type (eg. VariableDefinition, FunctionDefinition).
This is important when different kinds of definitions use different AST nodes.
Otherwise it is just boilerplate...
@; introduces these private rules:

Example:
@racketblock[
(add-to-grammar
 my-spec-component
 [VariableDefinition #f (name type Expression)]
 [FunctionDefinition #f (name type Body)]
 )
(add-prop
 my-spec-component
 lift-type->ast-binder-type
 [#f (Î» (type) (if (function-type? type)
                   'FunctionDefinition
                   'VariableDefinition))])
]
}


@defform[#:kind "spec-property" #:id choice-filters-to-apply choice-filters-to-apply]{

This property accepts a syntax list of choice-rule names to use as a filter for the node type.  Generally this should be set on the greatest super node type (or @racket[#f] if there is no explicit super node type in your grammar).  Each choice-rule in the list is called on the choice object with no arguments.  Each rule that returns @racket[#f] rules the node out as a choice for filling in a hole.

Example:
@racketblock[
(add-prop
 my-spec-component
 choice-filters-to-apply
 [#f (my-custom-filter-choice-rule my-other-filter-choice-rule)])
]

Some core methods are always applied in addition to this list, such as the method defined by the @racket[may-be-generated] property.
If you don't make custom filtering rules you don't need to specify this property.


}

@section{Types}

These type constructors and other functions are largely useful for specifying the @racket[type-info] property.

While there are various predicates for different types, at any point in type checking you might actually have a type variable instead of a concrete type.
So if you want to check if you have a particular type (and maybe deconstruct it), you should maybe create an instance of the type you are interested in, check if it @racket[can-unify?], then @racket[unify!]-ing it if you want to deconstruct it.
Note that if you do @racket[unify!] a type variable, that unification needs to be consistent between multiple runs of type checking (since it runs multiple times as the tree is constructed).


@defproc[(type? [t any/c]) bool?]{
Predicate for types.
}

@defproc[(fresh-type-variable [args type?] ...) type?]{
Creates a fresh type variable.  If given no arguments it is unconstrained and can unify with any type.  Arguments can be provided, in which case the type variable is constrained to be one of the types given.
In the optional arguments, only one function type is allowed.

Example:
@racketblock[
(code:comment "Unconstrained")
(define v1 (fresh-type-variable))

(define int (base-type 'int))
(define float (base-type 'float))
(define bool (base-type 'bool))

(define v2 (fresh-type-variable int bool))

(unify! v1 v2)

(can-unify? v1 float) (code:comment "#f")
(can-unify? v1 int) (code:comment "#t")

(unify! v2 bool)
(can-unify? v1 int) (code:comment "#f")
]
}

@defproc[(type-variable? [t any/c]) bool?]{
Predicate for type variables.
}

@defproc[(can-unify? [t1 type?] [t2 type?]) bool?]{
Returns whether two types can be unified without actually unifying them.
}
@defproc[(unify! [t1 type?] [t2 type?]) void?]{
Unifies two types.  This mutates type variables so that they match other variables or types going forward.

If unification fails an exception is raised.  Right now a failure to unify might mean that type variables are left in a bad state, so code generation should just give up at that point.
}

@defproc[(base-type [name symbol?]) type?]{
Creates a base type.  Base types with the same name are the same.
}


@defproc[(function-type [arg-type type?] [return-type type?]) type?]{
Creates a function type.
For multi-argument functions, use a @racket[product-type] for the argument type.
}
@defproc[(function-type? [t any/c]) bool?]{
Predicate for function types.
}
@defproc[(function-type-arg-type [t function-type?]) type?]{
Get the argument type.
Remember that you can't deconstruct type variables that are not fully constrained!
}
@defproc[(function-type-return-type [t function-type?]) type?]{
Get the return type.
Remember that you can't deconstruct type variables that are not fully constrained!
}


@defproc[(product-type [types (or/c (listof types?) #f)]) type?]{
Creates a product type (tuple).  If @racket[types] is @racket[#f], the length of the tuple is unspecified, and it can be @racket[unify!]-ed with a product type of any length.

Example:
@racketblock[
(define any-length (product-type #f))
(define l2 (product-type (list int int)))
(define l3 (product-type (list int int int)))

(can-unify? any-length l2) (code:comment "#t")
(can-unify? any-length l3) (code:comment "#t")
(unify! any-length l2)
(can-unify? any-length l2) (code:comment "#t")
(can-unify? any-length l3) (code:comment "#f")
]
}

@defproc[(product-type? [t any/c]) bool?]{
Predicate for product types.
}

@defproc[(product-type-inner-type-list [t product-type?]) any/c]{
Returns the list of types in the product-type, or @racket[#f] for a product-type with a length that is still unspecified.
}

@defform[(define-generic-type name (type-argument ...))]{
Used to create generic types.

This form defines a constructor @racket[name], a predicate @racket[name]@verb{?}, and one accessor for each type-argument @racket[name]@verb{-}@racket[type-argument] a la @racket[struct].

Each instance of a generic type can be unified with other instances of the same generic.

Example:
@racketblock[
(define int (base-type 'int))
(define-generic-type list-type (type))

(define t1 (list-type int))
(generic-type? t1) (code:comment "#t")
(list-type? t1) (code:comment "#t")
(generic-type-type-arguments t1) (code:comment "(list int)")
(list-type-type t1) (code:comment "int")

(define t2 (list-type (fresh-type-variable)))
(can-unify? t1 t2) (code:comment "#t")
(unify! t1 t2)
]
}

@defproc[(generic-type? [t any/c]) bool?]{
Returns true when @racket[t] is a generic type.
Not very useful, since you probably want to know if it is an instance of a specific generic.
}

@defproc[(generic-type-name [t generic-type?]) symbol?]{
Returns the name of a generic type.
Remember that you can't deconstruct type variables that are not fully constrained!
}
@defproc[(generic-type-type-arguments [t generic-type?]) (listof type?)]{
Returns the inner types of a generic type as a list.
Remember that you can't deconstruct type variables that are not fully constrained!
}


@defproc[(nominal-record-type? [t any/c]) bool?]{
Predicate for nominal record types.

Partially specified @racket[nominal-record-type?]s are created with @racket[nominal-record-type-with].
Fully specified @racket[nominal-record-type?]s are created by using @racket[concretize-type] on a partially specified one.
Rather than making them manually, simply rely on Xsmith's definition-lifting mechanism to create appropriate fully-specified @racket[nominal-record-type?]s.

When a partially defined @racket[nominal-record-type] is @racket[unify!]-ed with a fully defined @racket[nominal-record-type], the partially defined one is mutated to become the same as the fully defined one.
When two partially defined @racket[nominal-record-type]s are unified together, an error is raised.

Every node in a language grammar that stands for a @racket[nominal-record-type] constructor, accessor, or mutator must include a reference to a @racket[nominal-record-definition-type] containing the @racket[nominal-record-type] being used.

The reason for this is that nominal types must be defined in the program.
@racket[nominal-record-definition-type]s are necessary because the lookups of these type names are a different type than uses of the record type that the name is bound to.

Example:
@racketblock[
(add-to-grammar my-grammar
 ...
 [VariableReference Expression (name)]
 ...
 [StructReference Expression (fieldname
                              [structdefref : VariableReference]
                              [structval : Expression])]
 ...
 )

(add-prop
 my-grammar
 type-info
 ...
 [StructReference [(fresh-type-variable)
                   (Î» (n t)
                     (define type-with-field
                       (nominal-record-type-with (ast-child 'fieldname n) t))
                     (hash 'structval type-with-field
                           'structdefref (nominal-record-definition-type
                                          type-with-field)))]]
 ...
 )
]
}

@defproc[(nominal-record-type-with [fieldname string?] [fieldtype type?])
type?]{
Creates a partially-specified @racket[nominal-record-type?].
Use it to specify that you want a record that contains a certain type.
}

@defproc[(any-nominal-record-type) type?]{
Creates a completely unconstrained @racket[nominal-record-type?].
It will unify with any fully constrained @racket[nominal-record-type?].
}

@defproc[(nominal-record-type-name [t nominal-record-type?]) any/c]{
Getter for the name of a @racket[nominal-record-type?].
}
@defproc[(nominal-record-type-inners [t nominal-record-type?]) dict?]{
Getter for the inner type dictionary.
If you use this on a partially-specified @racket[nominal-record-type?], you will get an incomplete dictionary.
}

@defproc[(nominal-record-definition-type [t nominal-record-type?]) type?]{
Constructor.
See note in @racket[nominal-record-type?] for how it is used.
}
@defproc[(nominal-record-definition-type? [t any/c]) bool?]{
Predicate for nominal record definition types constructed with @racket[nominal-record-definition-type].
}
@defproc[(nominal-record-definition-type-type [t nominal-record-definition-type?]) nominal-record-type?]{
Getter for the @racket[nominal-record-type] inside a @racket[nominal-record-definition-type].
}

@defproc[(concretize-type [t type?]) type?]{
Returns a fully concrete (no type variables) type that @racket[can-unify?] with @racket[t].

This function can be useful if you want to generate a random type.  But beware!  You should probably NOT generate random types unless you also store them in the grammar node that represents that type.  The type-checking code defined in the @racket[type-info] property can be run many times for each node, so a node that randomly chooses its type will not be stable.  Because the type algorithm imperatively unifies types, this causes mayhem.  Don't do it.

Note that to use this function you must parameterize @racket[current-xsmith-type-constructor-thunks].  Probably in the @verb{generate-and-print} function passed to @racket[xsmith-command-line].
}

@defparam[current-xsmith-type-constructor-thunks thunk-list (listof (-> type?))]{
This needs to be parameterized for @racket[concretize-type], which is needed in code dealing with variable definition and reference.
It should consist of a list of thunks that each produce a fully concrete type when called.

The @verb{generate-and-print} function passed to @racket[xsmith-command-line] needs to parameterize this.
}



@section{Debug Logging}
@defproc[(xd-printf [format-string string?] [args (listof any/c)] ...) any/c]{
Like @racket[printf], but it prints to a buffer that is output when an exception is raised during program generation.
}



@section{Turning Your Grammar Specification Into a Program}

@defproc[(xsmith-command-line
[generate-and-print-func (-> any/c)]
[#:comment-wrap comment-wrap (-> (listof string?) string?)]
[#:features features (listof (list/c symbol? boolean?))])
any/c]{
This function parses the current command-line arguments for xsmith fuzzers.  It is basically to be used in the main function of a fuzzer.
Based on options supplied, it may print a help message and terminate the program, generate a single program, or start a web server to generate many programs.

@racket[generate-and-print-func] must be a function that generates and prints a single program.  It is called within @racket[xsmith-command-line] with the random seed parameterized according to command-line options (and for the web server reset and incremented for each call), and with all xsmith-options parameterized according to the command line.  The @racket[generate-and-print-func] needs to parameterize @racket[current-type-thunks-for-concretization] if your language is to support variable definitions and references.

@racket[comment-wrap] takes a list of strings which contain info about the generated program, such as the command line used to generate it and the random seed number.  It should return a string representing those lines commented out.  Such as the following, assuming the "#" character is the line-comment character in your language:

@racketblock[
(Î» (lines)
  (string-join
   (map (Î» (x) (format "# ~a" x)) lines)
   "\n"))]


@racket[features] takes a list of two-element lists containing a feature name (as a symbol) and a default value (as a boolean).  Each feature will be included in the command-line options as @verb{--with-<feature-name>}.  The values of these features is available via @racket[xsmith-feature-enabled?].


The command-line options given by @racket[xsmith-command-line] are:
@(command-line-options-table)

}

@defproc[(xsmith-feature-enabled? [feature symbol?]) boolean?]{
Returns the value set by the user via @racket[xsmith-command-line] for the given feature.
The feature name must have been supplied to the #:features argument of @racket[xsmith-command-line], or an error will be raised.
}

@defproc[(xsmith-max-depth) number?]{
Returns the maximum tree generation depth as set by the user via @racket[xsmith-command-line].
}






@section{RACR Convenience Functions}
@defmodule[xsmith/racr-convenience]

These are a group of convenience functions around @(racr).
They are not necessary, and some may not be the best choices.
But I have found them a little more convenient than using certain @(racr) APIs directly.

@defform[(expr->ast-list length-expression field-expression)]{
Creates an @racket[ast-list-node?] containing a list of length @racket[length-expression].
For each element of the list, @racket[field-expression] is evaluated again.
}

@defproc[(node-type [n any/c]) any/c]{
Returns the symbol of the type of n, or #f if n is not a proper non-bud, non-list @racket[ast-node?].

Wrapper for @racket[ast-node-type] that returns false rather than erroring when it gets bud nodes or list nodes...
}

@defproc[(parent-node [n any/c]) any/c]{
Wrapper for ast-parent that returns #f rather than erroring when the given node doesn't have a parent.
}

@defproc[(top-ancestor-node [n any/c]) any/c]{
Calls @racket[parent-node] until it reaches the last parent, and returns it.
}

@defproc[(node-subtype? [n any/c]) any/c]{
Wrapper for @racket[ast-subtype?] that returns #f rather than erroring when the given node is a bud, list, or non-node.
}

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@; End of file.
